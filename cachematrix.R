## This function is about saving computer time when calculating the mean of an inverse matrix
## But the actual point about doing it is to learn the scoping rules of R, specifically: lexical sccoping
## These functions are very similar with the makeVector() and cachemean() functions


## makeCacheMatrix() creates a special "matrix" object, which is call S3 object, 
#that can cache its inverse
#The function formal argument is a default value with an empty matrix "x"
#The first thing the function does is set the value "NULL" to the object "inv.m"
        # which will later be used to store the inverse matrix

#Nested in the makeCacheMatrix are four functions: 

# 1. set: which establish the value of a matrix "y" to the named parent environment of object x
        # and set the value "NULL" to the named parent environment of object inv.m, 
        # this action also clears another value (inverse matrix) previously calculated
# 2. get: which get the value of x (the matrix we want to inverse)
# 3. set.inverse: which assign the value of the input argument (solve) to 
        # the object "inv.m" in the parent environment 
# 4. get.inverse: which returns the value of the inverse matrix (inv.m)

# Finally, the function creates a list with the four functions mentioned above, to facilitate the 
# later access to the nested functions of the makeCacheMatrix


makeCacheMatrix <- function(x = matrix()) {
        inv.m <- NULL
        set <- function(y=matrix()) {
                x <<- y
                inv.m <<- NULL
        }
        get <- function() x
        set.inverse <- function(solve) inv.m <<- solve
        get.inverse <- function() inv.m
        list(set = set, get = get, 
             set.inverse = set.inverse,
             get.inverse = get.inverse)
}


# cacheSolve() computes the inverse of the special matrix object returned by the makeCacheMatrix above.
# This function can not run with an atomic vector, it only runs with an object
# generated by the makeCacheMatrix.

# In a nutshell, if the inverse has already been calculated (and the matrix has not changed), 
# then the cachesolve retrieve the inverse from the cache, along with the message "getting cached data"
# this involves the first four lines of the function

# If the inverse matrix has not been calculated, the solve() function does it, and assign the 
# value to the inv.m object and to the set.inverse function inside the makeCacheMatrix

# ?solve #remove the first hashtag if you want to know what de solve() function does

cacheSolve <- function(x, ...) {
        ## Return a matrix that is the inverse of 'x'
        inv.m <- x$get.inverse()
        if(!is.null(inv.m)) {
                message("getting cached data")
                return(inv.m)
        }
        data <- x$get()
        inv.m <- solve(data, ...)
        x$set.inverse(inv.m)
        inv.m
        
}

## A TEST USING THE MATRIX EXAMPLE OF THE DISCUSSION FORUM OF WEEK 3
## I did it and I get the expected matrix, so I hope all of you also get the inverse matrix

## This matrix does have an inverse
m1 <- matrix(c(1/2, -1/4, -1, 3/4), nrow = 2, ncol = 2)

## The object myMatrix_object stores de matrix m1, but DOES NOT calculate the inverse
#it just creates the object used by the cacheSolve() function
myMatrix_object <- makeCacheMatrix(m1)

## This function DOES calculate and retrieves the inverse of the matrix
cacheSolve(myMatrix_object)
